name: CI/CD Pipeline

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:

concurrency:
  group: ${{ github.ref || github.run_id }}
  cancel-in-progress: true

env:
  REGISTRY: ghcr.io

jobs:
  build-and-push:
    outputs:
      image_full: ${{ steps.set_tag.outputs.image_full }}
      image_tag: ${{ steps.set_tag.outputs.image_tag }}

    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: âš™ï¸ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: ğŸ” Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ·ï¸ Set image tag
        id: set_tag
        run: |
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
          REPO=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]' | sed 's#[ _]#-#g' | sed 's/[^a-z0-9./-]/-/g')

          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            TAG="manual-$(date +%Y%m%d-%H%M%S)"
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            TAG="latest-$(date +%Y%m%d)"
          else
            TAG="${{ github.ref_name }}-$SHORT_SHA"
            TAG=$(echo "$TAG" | tr '[:upper:]' '[:lower:]' | sed 's#[/ _]#-#g' | sed 's/[^a-z0-9.-]/-/g')
          fi

          IMAGE="${{ env.REGISTRY }}/$REPO:$TAG"
          echo "image_full=$IMAGE" >> $GITHUB_OUTPUT
          echo "image_tag=$TAG" >> $GITHUB_OUTPUT

          if [[ "$TAG" == latest-* ]]; then
            echo "IMAGE_TAGS=$IMAGE,${{ env.REGISTRY }}/$REPO:latest" >> $GITHUB_ENV
          else
            echo "IMAGE_TAGS=$IMAGE" >> $GITHUB_ENV
          fi

      - name: ğŸ³ Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64
          push: true
          tags: ${{ env.IMAGE_TAGS }}
          labels: |
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.source=${{ github.event.repository.html_url }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    environment: production
    if: github.ref == 'refs/heads/main'
    timeout-minutes: 10

    env:
      SERVICE_NAME: ${{ vars.SERVICE_NAME || 'frontend' }}
      DEPLOY_PATH: ${{ vars.DEPLOY_PATH }}

    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ğŸ’¾ Pull, save & compress image
        run: |
          echo "ğŸ“¥ Pulling image: ${{ needs.build-and-push.outputs.image_full }}"
          docker pull "${{ needs.build-and-push.outputs.image_full }}"
          docker save "${{ needs.build-and-push.outputs.image_full }}" | gzip > image.tar.gz

      - name: ğŸ“¤ Copy compressed image to VPS
        uses: appleboy/scp-action@v1.0.0
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: ${{ secrets.VPS_PORT || 22 }}
          source: 'image.tar.gz'
          target: '${{ env.DEPLOY_PATH }}'

      - name: ğŸš€ Deploy to VPS with validation & rollback
        uses: appleboy/ssh-action@v1.2.2
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: ${{ secrets.VPS_PORT || 22 }}
          script: |
            #!/bin/bash
            set -e

            DEPLOY_PATH="${{ env.DEPLOY_PATH }}"
            SERVICE_NAME="${{ env.SERVICE_NAME }}"
            NEW_IMAGE="${{ needs.build-and-push.outputs.image_full }}"

            if [ ! -d "$DEPLOY_PATH" ]; then
              echo "âŒ DEPLOY_PATH does not exist: $DEPLOY_PATH"
              exit 1
            fi

            cd "$DEPLOY_PATH"

            # Load new image
            echo "ğŸ“¦ Loading new image..."
            gunzip -c image.tar.gz | docker load

            # ğŸ” Validation: run container for health check
            echo "ğŸ§ª Validating image..."
            CONTAINER_ID=$(docker run -d --rm --name temp-validate "$NEW_IMAGE")
            sleep 3

            if docker inspect -f '{{.State.Running}}' "$CONTAINER_ID" 2>/dev/null | grep -q 'true'; then
              echo "âœ… Validation passed."
            else
              echo "âŒ Container failed to start."
              docker logs "$CONTAINER_ID" 2>/dev/null || true
              docker rm -f "$CONTAINER_ID" 2>/dev/null || true
              exit 1
            fi
            docker kill "$CONTAINER_ID" >/dev/null 2>&1 || true

            # ğŸ” Capture current image for rollback
            OLD_IMAGE=""
            if docker compose ps -q | grep -q .; then
              CURRENT_IMAGE_LINE=$(docker compose images "$SERVICE_NAME" 2>/dev/null | tail -n1)
              OLD_IMAGE=$(echo "$CURRENT_IMAGE_LINE" | awk '{print $2}' | head -n1)
              if [ -n "$OLD_IMAGE" ] && [ "$OLD_IMAGE" != "<none>" ]; then
                echo "ğŸ” Saved rollback image: $OLD_IMAGE"
              fi
            else
              echo "â„¹ï¸ No running service â€” rollback not available."
            fi

            # ğŸš€ Deploy new version
            echo "ğŸš€ Deploying new version..."
            docker compose down --remove-orphans || true

            set +e
            APP_IMAGE="$NEW_IMAGE" docker compose up -d --remove-orphans
            DEPLOY_EXIT_CODE=$?
            set -e

            if [ $DEPLOY_EXIT_CODE -ne 0 ]; then
              echo "âŒ Deployment failed (exit code: $DEPLOY_EXIT_CODE)"
              if [ -n "$OLD_IMAGE" ]; then
                echo "ğŸ”„ Rolling back to: $OLD_IMAGE"
                APP_IMAGE="$OLD_IMAGE" docker compose up -d --remove-orphans
                echo "âœ… Rollback completed."
              else
                echo "âš ï¸ No rollback image available."
              fi
              exit $DEPLOY_EXIT_CODE
            else
              echo "âœ… Deployment succeeded."
              # ğŸ§¹ Cleanup old images (optional but recommended)
              docker image prune -f
            fi

            # ğŸ—‘ï¸ Final cleanup
            rm -f image.tar.gz
            echo "ğŸ‰ Deployment completed successfully."
